use std::collections::HashMap;

use bevy::prelude::*;
use pyo3::types::{IntoPyDict, PyList};
use pyo3::{exceptions::PyLookupError, prelude::*};

fn setup_scripts() {
  Python::with_gil(|_py| {
    // TODO: imports etc etc
  });
}

#[pyclass]
#[derive(Default)]
struct GameState {
  world: World,
  resources: Resources,
}

impl GameState {
  pub fn fetch<'a>(py: &'a Python) -> &'a PyCell<Self> {
    py.eval("world", None, None)
      .unwrap()
      .downcast::<PyCell<Self>>()
      .unwrap()
  }
}

#[pymethods]
impl GameState {
  pub fn entity_with_name(&self, name: String) -> PyResult<CEntity> {
    self
      .world
      .query::<(Entity, &Name)>()
      .find(|(_, name_component)| name == name_component.as_str())
      .map(|(entity, _)| CEntity { entity })
      .ok_or_else(|| PyErr::new::<PyLookupError, _>(format!("Name {} does not exist", name)))
  }
}

#[pyclass]
struct CEntity {
  entity: Entity,
}

#[pymethods]
impl CEntity {
  pub fn transform(&self, py: Python) -> PyResult<CTransform> {
    let game_state = GameState::fetch(&py);
    game_state
      .borrow()
      .world
      .get::<Transform>(self.entity)
      .map(|transform| CTransform {
        transform: *transform,
      })
      .map_err(|_| {
        PyErr::new::<PyLookupError, _>(format!("Entity {:?} does not have Transform", self.entity))
      })
  }
}

#[pyclass]
struct CVec3 {
  vec: Vec3,
}

#[pymethods]
impl CVec3 {
  fn to_list(&self, py: Python) -> Py<PyAny> {
    vec![self.vec.x, self.vec.y, self.vec.z].into_py(py)
  }
}

#[pyclass]
struct CTransform {
  transform: Transform,
}

#[pymethods]
impl CTransform {
  pub fn position(&self) -> CVec3 {
    CVec3 {
      vec: self.transform.translation.clone(),
    }
  }
}

const SCRIPT: &'static str = r#"
print(world.entity_with_name("player body").transform().position().to_list())
"#;

fn run_scripts(world: &mut World, resources: &mut Resources) {
  Python::with_gil(|py| {
    take_mut::scoped::scope(|scope| {
      let (world, world_hole) = scope.take(world);
      let (resources, resources_hole) = scope.take(resources);
      let game_state = Py::new(py, GameState { world, resources }).unwrap();

      let mut globals = HashMap::new();
      globals.insert("world", game_state.clone());
      if let Err(e) = py.run(SCRIPT, None, Some(globals.into_py_dict(py))) {
        warn!("{}", e);
      }

      let GameState { world, resources } = game_state.as_ref(py).replace(Default::default());
      world_hole.fill(world);
      resources_hole.fill(resources);
    });
  });
}

pub struct ScriptsPlugin;

impl Plugin for ScriptsPlugin {
  fn build(&self, app: &mut AppBuilder) {
    app
      .add_startup_system(setup_scripts.system())
      .add_system(run_scripts.system());
  }
}
